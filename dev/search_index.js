var documenterSearchIndex = {"docs":
[{"location":"schedule_synthesis/#Schedule-Synthesis","page":"Schedule Synthesis","title":"Schedule Synthesis","text":"","category":"section"},{"location":"schedule_synthesis/","page":"Schedule Synthesis","title":"Schedule Synthesis","text":"The main functionality of this section is divided into two functions","category":"page"},{"location":"schedule_synthesis/","page":"Schedule Synthesis","title":"Schedule Synthesis","text":"synthesize_constraints: given the dynamics and safety margin of one control task, find all weakly-hard constraints (up to a maximum window size maxwindow) with which the system behaves safely, and\nschedule_xghtc: given the lists of safe weakly-hard constraints for all  control tasks, synthesizes a schedule so that they all behave safely (if such schedules  exist).","category":"page"},{"location":"schedule_synthesis/","page":"Schedule Synthesis","title":"Schedule Synthesis","text":"synthesize_constraints\nschedule_xghtc","category":"page"},{"location":"schedule_synthesis/#ControlTimingSafety.synthesize_constraints","page":"Schedule Synthesis","title":"ControlTimingSafety.synthesize_constraints","text":"synthesize_constraints(sysd, K, z_0, d_max, maxwindow, n, t)\n\nFind all MeetAny weakly hard constraints with window size at most maxwindow that  guarantees the deviation upper bound is at most d_max. The system is specified by  Automaton a and initial state is z_0. n and t are as in  bounded_runs_iter.\n\n\n\n\n\n","category":"function"},{"location":"schedule_synthesis/#ControlTimingSafety.schedule_xghtc","page":"Schedule Synthesis","title":"ControlTimingSafety.schedule_xghtc","text":"schedule_xghtc(constraints; slotsize=1, H=100, work_conserving=false)\n\nGenerate a schedule for a set of weakly hard constraints. The schedule returned has the  type Matrix{Int64}, where the first dimension iterates through tasks, and the second through time slots. If no safe schedule can be found, an empty Matrix{Int64} is returned. If the schedule returned is shorter than then time horizon H, it means the schedule is to be repeated and the system will still be safe until H.\n\nThe schedule assumes that all tasks are synchronous and have equal periods. At most  slotsize tasks may be scheduled in a single period. The schedule has total length H periods, or it can be shorter if a cycle is found.\n\nShengjie Xu, Bineet Ghosh, Clara Hobbs, P.S. Thiagarajan, and Samarjit Chakraborty,  \"Safety-Aware Flexible Schedule Synthesis for Cyber-Physical Systems using Weakly-Hard  Constraints.\"  ASPDAC 2023.  DOI: 10.1145/3566097.3567848\n\n\n\n\n\n","category":"function"},{"location":"probablesafety/#Probable-Safety","page":"Probable Safety","title":"Probable Safety","text":"","category":"section"},{"location":"probablesafety/","page":"Probable Safety","title":"Probable Safety","text":"In the paper \"Statistical Hypothesis Testing of Controller Implementations Under Timing Uncertainties,\" we developed a method for estimating the maximum deviation of a control system that may experience deadline misses.  This estimate is based on Jeffreys' Bayes factor hypothesis testing, and is probabilistically guaranteed.  The method is implemented in the estimate_deviation function.","category":"page"},{"location":"probablesafety/","page":"Probable Safety","title":"Probable Safety","text":"estimate_deviation\nmaximum_deviation_random","category":"page"},{"location":"probablesafety/#ControlTimingSafety.estimate_deviation","page":"Probable Safety","title":"ControlTimingSafety.estimate_deviation","text":"estimate_deviation(a, sampler, z_0, c, B; nominal, nominal_trajectory,\n                   estimate, estimate_samples, ϵ)\n\nEstimate the deviation possible in the Automaton a, using sampler to generate random behaviors.  The initial state is given as z_0.  c specifies the confidence with which the returned value is asserted to be an upper bound, and B is the Bayes factor used in hypothesis testing.  The parameters metric, nominal, and nominal_trajectory are as in deviation.\n\nIf estimate is given, this value is used as the initial estimate for the first hypothesis formulated.  Otherwise, estimate_samples random runs (default: 50) are taken, and the greatest deviation seen is used for the first hypothesis.  A pad of ϵ is added to each subsequent hypothesis.\n\nFor more information, see Bineet Ghosh et al., \"Statistical Hypothesis Testing of Controller Implementations Under Timing Uncertainties,\" RTCSA 2022.  DOI: 10.1109/RTCSA55878.2022.00008\n\n\n\n\n\n","category":"function"},{"location":"probablesafety/#ControlTimingSafety.maximum_deviation_random","page":"Probable Safety","title":"ControlTimingSafety.maximum_deviation_random","text":"maximum_deviation_random(a, sampler, z_0, samples; estimate, metric, nominal,\n                         nominal_trajectory)\n\nCalculate samples random behaviors using sampler, and the corresponding trajectories of the Automaton a from the initial state z_0.  Return the maximum deviation from a nominal trajectory.  The parameters metric, nominal, and nominal_trajectory are as in deviation.  If estimate is specified, stop early if this deviation estimate is exceeded, returning the exceeding deviation.\n\n\n\n\n\n","category":"function"},{"location":"automata/#Automata","page":"Automata","title":"Automata","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"To represent the different control behaviors that can result from deadline misses, we make use of finite-state transducer automata.  These take as input a sequence of small integers representing deadline hits and misses, or potentially other scheduler actions.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"Automaton\nAutomaton(::Automaton, ::Int64)","category":"page"},{"location":"automata/#ControlTimingSafety.Automaton","page":"Automata","title":"ControlTimingSafety.Automaton","text":"Automaton(Φ, T, μ, l_int)\n\nA transducer automaton.\n\nSee also the constructors hold_kill, hold_skip_next, zero_kill, and zero_skip_next, which create Automaton objects for common deadline miss handling strategies.  For use in notebooks, etc., see strat_map and strat_names.\n\n\n\n\n\n","category":"type"},{"location":"automata/#ControlTimingSafety.Automaton-Tuple{Automaton, Int64}","page":"Automata","title":"ControlTimingSafety.Automaton","text":"Automaton(a, l_int)\n\nConstruct a copy of the Automaton a with a new l_int.\n\n\n\n\n\n","category":"method"},{"location":"automata/#Constructors-for-Miss-Handling-Strategies","page":"Automata","title":"Constructors for Miss Handling Strategies","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"As a user of ControlTimingSafety, you will likely not want to construct an Automaton directly.  The package provides external constructors that create an Automaton from a StateSpace model from ControlSystems.jl, following different strategies of how to handle deadline misses.  Constraints may be specified using WeaklyHardConstraint objects from RealTimeScheduling.jl.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"note: Note\nCurrently, only MissRow constraints are supported, but more constraints will be added in the future!","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"hold_kill\nhold_skip_next\nzero_kill\nzero_skip_next","category":"page"},{"location":"automata/#ControlTimingSafety.hold_kill","page":"Automata","title":"ControlTimingSafety.hold_kill","text":"hold_kill(sysd, K, [c])\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Hold&Kill strategy.  If c is specified, the resulting Automaton will permit only that weakly hard constraint.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.hold_skip_next","page":"Automata","title":"ControlTimingSafety.hold_skip_next","text":"hold_skip_next(sysd, K, [c])\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Hold&Skip-Next strategy.  If c is specified, the resulting Automaton will permit only that weakly hard constraint.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.zero_kill","page":"Automata","title":"ControlTimingSafety.zero_kill","text":"zero_kill(sysd, K, [c])\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Zero&Kill strategy.  If c is specified, the resulting Automaton will permit only that weakly hard constraint.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.zero_skip_next","page":"Automata","title":"ControlTimingSafety.zero_skip_next","text":"zero_skip_next(sysd, K, [c])\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Zero&Skip-Next strategy.  If c is specified, the resulting Automaton will permit only that weakly hard constraint.\n\n\n\n\n\n","category":"function"},{"location":"automata/","page":"Automata","title":"Automata","text":"For convenience when building interfaces, e.g. notebooks, we also export a sorted list of human-readable names for these constructors, and a map from these names to the functions themselves.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"strat_names\nstrat_map","category":"page"},{"location":"automata/#ControlTimingSafety.strat_names","page":"Automata","title":"ControlTimingSafety.strat_names","text":"A stable, sorted list of the human-readable names in strat_map.\n\n\n\n\n\n","category":"constant"},{"location":"automata/#ControlTimingSafety.strat_map","page":"Automata","title":"ControlTimingSafety.strat_map","text":"A mapping from human-readable names to Automaton constructor functions.\n\nSee also strat_names.\n\n\n\n\n\n","category":"constant"},{"location":"automata/#Computing-Evolution","page":"Automata","title":"Computing Evolution","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"Given an initial state z0 and a sequence of scheduler actions seq, the evolution of an Automaton can be computed.  Since the augmented state space requires extra state variables outside the plant's state, the state z0 can be computed from a plant state x0 using the augment function.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"augment","category":"page"},{"location":"automata/#ControlTimingSafety.augment","page":"Automata","title":"ControlTimingSafety.augment","text":"augment(a::Automaton, x)\n\nPad the state vector (or matrix of column vectors) x to as many dimensions as in the augmented state space of a.\n\n\n\n\n\n","category":"function"},{"location":"automata/","page":"Automata","title":"Automata","text":"Once the initial augmented state is determined, we can then compute its evolution.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"evol\nevol_final\nevol!\nevol_final!","category":"page"},{"location":"automata/#ControlTimingSafety.evol","page":"Automata","title":"ControlTimingSafety.evol","text":"evol(a, z_0, input)\n\nSimulate a run of Automaton a from the initial state z_0, using the sequence of scheduler events input.\n\nReturns z, a matrix of states over time.\n\nSee also evol_final, which additionally returns the final location in the automaton.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.evol_final","page":"Automata","title":"ControlTimingSafety.evol_final","text":"evol_final(a, z_0, input)\n\nSame as evol, but returns (z, l), where z is a matrix of states over time, and l is the final location in the automaton.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.evol!","page":"Automata","title":"ControlTimingSafety.evol!","text":"evol!(a, z, input)\n\nSame as evol, but writes to the input matrix z, whose first row is z_0.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.evol_final!","page":"Automata","title":"ControlTimingSafety.evol_final!","text":"evol_final!(a, z, input)\n\nSame as evol_final, but writes to the input matrix z, whose first row is z_0.\n\n\n\n\n\n","category":"function"},{"location":"#ControlTimingSafety.jl","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Tools for verifying safety of control systems that may experience timing uncertainty","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"This package provides tools for calculating safe overapproximations and probabilistic estimations of the maximum deviation a control system may suffer due to deadline misses.  If you find these tools useful in your research, please consider Citing the papers that the algorithms originated in.","category":"page"},{"location":"#Installation","page":"ControlTimingSafety.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"From the Julia REPL, run:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"using Pkg; Pkg.add(url=\"https://github.com/Ratfink/ControlTimingSafety.jl\")","category":"page"},{"location":"#Usage","page":"ControlTimingSafety.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Given a discrete-time state space model sys from the ControlSystems.jl package, and a feedback gain matrix K, first create an Automaton object using one of the constructors for the strategies described in the paper:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"hk = hold_kill(sys, K, max_misses)\nhs = hold_skip_next(sys, K, max_misses)\nzk = zero_kill(sys, K, max_misses)\nzs = zero_skip_next(sys, K, max_misses)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"To run the Bounded Runs Iteration algorithm for this automaton, first create the initial set, then run the algorithm for a given per-iteration run length n and number of iterations t:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"augbounds = augment(automaton, bounds)\nall_bounds = bounded_runs_iter(automaton, augbounds, n, t)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"The deviation at each time step can then be computed thusly:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"d = deviation(automaton, augbounds, all_bounds)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"For a complete example, see the demo Pluto notebook, notebooks/control_timing_safety.jl, included in the package.","category":"page"},{"location":"#Citing","page":"ControlTimingSafety.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"If you use this code in your research, we ask that you consider citing the relevant papers.  For the bounded_runs_iter function for overapproximating the maximum deviation, please cite:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Clara Hobbs, Bineet Ghosh, Shengjie Xu, Parasara Sridhar Duggirala, and Samarjit Chakraborty. \"Safety Analysis of Embedded Controllers under Implementation Platform Timing Uncertainties.\" TCAD 2022. DOI: 10.1109/TCAD.2022.3198905","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"For the estimate_deviation function, based on Jeffreys' Bayes factor hypothesis testing, please cite:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Bineet Ghosh, Clara Hobbs, Shengjie Xu, Parasara Sridhar Duggirala, James H. Anderson, P. S. Thiagarajan, and Samarjit Chakraborty. \"Statistical Hypothesis Testing of Controller Implementations Under Timing Uncertainties.\" RTCSA 2022. DOI: 10.1109/RTCSA55878.2022.00008","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"For the synthesize_constraints function to generate the list of safe weakly-hard constraints and schedule_xghtc function to synthesize schedules from weakly-hard constraints, please cite:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Shengjie Xu, Bineet Ghosh, Clara Hobbs, P. S. Thiagarajan, and Samarjit  Chakraborty.  \"Safety-Aware Flexible Schedule Synthesis for Cyber-Physical Systems Using Weakly-Hard Constraints.\"  ASPDAC 2023. DOI: 10.1145/3566097.3567848","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"As we continue this line of work, we intend to incorporate new algorithms in this package, and the list of papers will be updated accordingly (along with specific the functions described in each).","category":"page"},{"location":"safety/#Checking-Safety","page":"Checking Safety","title":"Checking Safety","text":"","category":"section"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"The main safety-checking function of ControlTimingSafety is bounded_runs_iter, which implements the Bounded Runs Iteration algorithm from \"Safety Analysis of Embedded Controllers under Implementation Platform Timing Uncertainties.\"  This implementation permits an initial point, or an axis-aligned box initial set.  The helper function bounded_runs, which computes a single iteration, is also exported.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"bounded_runs_iter\nbounded_runs","category":"page"},{"location":"safety/#ControlTimingSafety.bounded_runs_iter","page":"Checking Safety","title":"ControlTimingSafety.bounded_runs_iter","text":"bounded_runs_iter(a, z_0, n, t)\n\nIterate bounded_runs(a, z_0, n) for t iterations, returning the reachable set at each of the n×t+1 time steps.\n\nSee also deviation, which can be called with the result of this function to find the deviation from a nominal trajectory.\n\n\n\n\n\n","category":"function"},{"location":"safety/#ControlTimingSafety.bounded_runs","page":"Checking Safety","title":"ControlTimingSafety.bounded_runs","text":"bounded_runs(a::Automaton, z_0, n)\n\nCompute reachable sets for n time steps for the given Automaton a, starting from the initial set given by z_0.\n\nz_0 must be an a.nz-element vector, or an a.nz×2 matrix whose first and second columns are the minimum and maximum along each dimension, respectively.\n\nReturns (bounds, locs), where bounds is an nactions(a)^n×n+1×a.nz×2 Array{Float64} giving the bounding box for each (run, time step), and locs is an nactions(a)^n Array{Int64} of final locations for each run (or zero if there is no such run).\n\nSee also bounded_runs_iter, which calls this function iteratively to efficiently compute reachable sets for longer time horizons.  Typically one will call deviation on the results of this function to determine deviation from a nominal trajectory.\n\n\n\n\n\n","category":"function"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"After computing a list of reachable sets, safety can be determined by computing its distance from a nominal run.  This is done using the deviation function.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"deviation","category":"page"},{"location":"safety/#ControlTimingSafety.deviation","page":"Checking Safety","title":"ControlTimingSafety.deviation","text":"deviation(a, z_0, reachable; metric=Euclidean(), nominal=[1,1,...])\n\nCompute the deviation from the nominal behavior (default: all 1) that is possible for the given Automaton a, starting from the set of initial states z_0, within the reachable sets.  The deviation is computed using the specified metric from the Distances.jl package, on the output of the system (i.e. after multiplying by a.C).  reachable may be the three-dimensional output of e.g. bounded_runs_iter, or a matrix with dimensions (state, time), e.g. from evol.\n\nIf nominal_trajectory is given, this trajectory is used instead of computing the trajectory from the nominal behavior.  This can improve efficiency when calling deviation iteratively.\n\nSee also bounded_runs and bounded_runs_iter, which can be used to compute reachable.\n\n\n\n\n\n","category":"function"},{"location":"safety/#Utility-Functions","page":"Checking Safety","title":"Utility Functions","text":"","category":"section"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"A few utility functions are exported as well.  These support the implementation of the above functions, and are potentially useful to their callers as well.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"corners_from_bounds\nmerge_bounds\nmerge_bounds!","category":"page"},{"location":"safety/#ControlTimingSafety.corners_from_bounds","page":"Checking Safety","title":"ControlTimingSafety.corners_from_bounds","text":"corners_from_bounds(bounds::AbstractMatrix; cycle=false, dims=axes(bounds, 1))\n\nReturns the corners of the n-dimensional interval represented by bounds.  If cycle is true, the first corner is repeated at the end, and the corners are given in Gray code order.  Only the dimensions from dims are considered.\n\n\n\n\n\ncorners_from_bounds(bounds::AbstractVector; cycle=nothing, dims=nothing)\n\nWhen applied to a vector, cast it to a one-column matrix.  cycle and dims are ignored.\n\n\n\n\n\n","category":"function"},{"location":"safety/#ControlTimingSafety.merge_bounds","page":"Checking Safety","title":"ControlTimingSafety.merge_bounds","text":"merge_bounds(b)\n\nMerges an array of bounding boxes b into one.\n\nSee also merge_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"safety/#ControlTimingSafety.merge_bounds!","page":"Checking Safety","title":"ControlTimingSafety.merge_bounds!","text":"merge_bounds!(r, b)\n\nMerges an array of bounding boxes b into one, storing the result in r.\n\nSee also merge_bounds.\n\n\n\n\n\n","category":"function"}]
}
