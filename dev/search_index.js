var documenterSearchIndex = {"docs":
[{"location":"automata/#Automata","page":"Automata","title":"Automata","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"To represent the different control behaviors that can result from deadline misses, we make use of finite-state transducer automata.  These take as input a sequence of small integers representing deadline hits and misses, or potentially other scheduler actions.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"Automaton\nAutomaton(::Automaton, ::Int64)","category":"page"},{"location":"automata/#ControlTimingSafety.Automaton","page":"Automata","title":"ControlTimingSafety.Automaton","text":"Automaton(Φ, T, μ, l_int)\n\nA transducer automaton.\n\nSee also the constructors hold_kill, hold_skip_next, zero_kill, and zero_skip_next, which create Automaton objects for common deadline miss handling strategies.  For use in notebooks, etc., see strat_map and strat_names.\n\n\n\n\n\n","category":"type"},{"location":"automata/#ControlTimingSafety.Automaton-Tuple{Automaton, Int64}","page":"Automata","title":"ControlTimingSafety.Automaton","text":"Automaton(a, l_int)\n\nConstruct a copy of the Automaton a with a new l_int.\n\n\n\n\n\n","category":"method"},{"location":"automata/#Constructors-for-Miss-Handling-Strategies","page":"Automata","title":"Constructors for Miss Handling Strategies","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"As a user of ControlTimingSafety, you will likely not want to construct an Automaton directly.  The package provides external constructors that create an Automaton from a StateSpace model from ControlSystems.jl, following different strategies of how to handle deadline misses.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"hold_kill\nhold_skip_next\nzero_kill\nzero_skip_next","category":"page"},{"location":"automata/#ControlTimingSafety.hold_kill","page":"Automata","title":"ControlTimingSafety.hold_kill","text":"hold_kill(sysd, K, miss=nothing)\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Hold&Kill strategy, with at most miss deadline misses.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.hold_skip_next","page":"Automata","title":"ControlTimingSafety.hold_skip_next","text":"hold_skip_next(sysd, K, miss=nothing)\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Hold&Skip-Next strategy, with at most miss deadline misses.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.zero_kill","page":"Automata","title":"ControlTimingSafety.zero_kill","text":"zero_kill(sysd, K, miss=nothing)\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Zero&Kill strategy, with at most miss deadline misses.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.zero_skip_next","page":"Automata","title":"ControlTimingSafety.zero_skip_next","text":"zero_skip_next(sysd, K, miss=nothing)\n\nConstruct an Automaton for the given discrete-time state space model sysd with feedback gain matrix K, following the Zero&Skip-Next strategy, with at most miss deadline misses.\n\n\n\n\n\n","category":"function"},{"location":"automata/","page":"Automata","title":"Automata","text":"For convenience when building interfaces, e.g. notebooks, we also export a sorted list of human-readable names for these constructors, and a map from these names to the functions themselves.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"strat_names\nstrat_map","category":"page"},{"location":"automata/#ControlTimingSafety.strat_names","page":"Automata","title":"ControlTimingSafety.strat_names","text":"A stable, sorted list of the human-readable names in strat_map.\n\n\n\n\n\n","category":"constant"},{"location":"automata/#ControlTimingSafety.strat_map","page":"Automata","title":"ControlTimingSafety.strat_map","text":"A mapping from human-readable names to Automaton constructor functions.\n\nSee also strat_names.\n\n\n\n\n\n","category":"constant"},{"location":"automata/#Computing-Evolution","page":"Automata","title":"Computing Evolution","text":"","category":"section"},{"location":"automata/","page":"Automata","title":"Automata","text":"Given an initial state z0 and a sequence of scheduler actions seq, the evolution of an Automaton can be computed.  Since the augmented state space requires extra state variables outside the plant's state, the state z0 can be computed from a plant state x0 using the augment function.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"augment","category":"page"},{"location":"automata/#ControlTimingSafety.augment","page":"Automata","title":"ControlTimingSafety.augment","text":"augment(a::Automaton, x)\n\nPad the state vector (or matrix of column vectors) x to as many dimensions as in the augmented state space of a.\n\n\n\n\n\n","category":"function"},{"location":"automata/","page":"Automata","title":"Automata","text":"Once the initial augmented state is determined, we can then compute its evolution.","category":"page"},{"location":"automata/","page":"Automata","title":"Automata","text":"evol\nevol_final","category":"page"},{"location":"automata/#ControlTimingSafety.evol","page":"Automata","title":"ControlTimingSafety.evol","text":"evol(a, z_0, input)\n\nSimulate a run of Automaton a from the initial state z_0, using the sequence of scheduler events input.\n\nReturns z, a matrix of states over time.\n\nSee also evol_final, which additionally returns the final location in the automaton.\n\n\n\n\n\n","category":"function"},{"location":"automata/#ControlTimingSafety.evol_final","page":"Automata","title":"ControlTimingSafety.evol_final","text":"evol_final(a, z_0, input)\n\nSame as evol, but returns (z, l), where z is a matrix of states over time, and l is the final location in the automaton.\n\n\n\n\n\n","category":"function"},{"location":"#ControlTimingSafety.jl","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Tools for verifying safety of control systems that may experience timing uncertainty","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"This package, for the time being, consists primarily of an implementation of the Bounded Runs Iteration algorithm from the paper \"Safety Analysis of Embedded Controllers under Implementation Platform Timing Uncertainties.\"  See the Citing section below for more information.","category":"page"},{"location":"#Installation","page":"ControlTimingSafety.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"From the Julia REPL, run:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"using Pkg; Pkg.add(url=\"https://github.com/Ratfink/ControlTimingSafety.jl\")","category":"page"},{"location":"#Usage","page":"ControlTimingSafety.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Given a discrete-time state space model sys from the ControlSystems.jl package, and a feedback gain matrix K, first create an Automaton object using one of the constructors for the strategies described in the paper:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"hk = hold_kill(sys, K, max_misses)\nhs = hold_skip_next(sys, K, max_misses)\nzk = zero_kill(sys, K, max_misses)\nzs = zero_skip_next(sys, K, max_misses)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"To run the Bounded Runs Iteration algorithm for this automaton, first create the initial set, then run the algorithm for a given per-iteration run length n and number of iterations t:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"augbounds = augment(automaton, bounds)\nall_bounds = bounded_runs_iter(automaton, augbounds, n, t)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"The deviation at each time step can then be computed thusly:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"d = deviation(automaton, augbounds, all_bounds)","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"For a complete example, see the demo Pluto notebook, notebooks/control_timing_safety.jl, included in the package.","category":"page"},{"location":"#Citing","page":"ControlTimingSafety.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"If you use this code in your research, we ask that you consider citing the relevant paper.  Currently, this means the following:","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"Clara Hobbs, Bineet Ghosh, Shengjie Xu, Parasara Sridhar Duggirala, and Samarjit Chakraborty. \"Safety Analysis of Embedded Controllers under Implementation Platform Timing Uncertainties.\" TCAD 2022.","category":"page"},{"location":"","page":"ControlTimingSafety.jl","title":"ControlTimingSafety.jl","text":"As we continue this line of work, we intend to incorporate new algorithms in this package, and the list of papers will be updated accordingly (along with specific the functions described in each).","category":"page"},{"location":"safety/#Checking-Safety","page":"Checking Safety","title":"Checking Safety","text":"","category":"section"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"The main safety-checking function of ControlTimingSafety is bounded_runs_iter, which implements the Bounded Runs Iteration algorithm from \"Safety Analysis of Embedded Controllers under Implementation Platform Timing Uncertainties.\"  This implementation permits an initial point, or an axis-aligned box initial set.  The helper function bounded_runs, which computes a single iteration, is also exported.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"bounded_runs_iter\nbounded_runs","category":"page"},{"location":"safety/#ControlTimingSafety.bounded_runs_iter","page":"Checking Safety","title":"ControlTimingSafety.bounded_runs_iter","text":"bounded_runs_iter(a, bounds, n, t)\n\nIterate bounded_runs(a, bounds, n) for t iterations, returning the reachable set at each of the n×t+1 time steps.\n\nSee also deviation, which can be called with the result of this function to find the deviation from a nominal trajectory.\n\n\n\n\n\n","category":"function"},{"location":"safety/#ControlTimingSafety.bounded_runs","page":"Checking Safety","title":"ControlTimingSafety.bounded_runs","text":"bounded_runs(a::Automaton, bounds, n)\n\nCompute reachable sets for n time steps for the given Automaton a, starting from the initial set given by bounds.\n\nbounds must be an a.nz-element vector, or an a.nz×2 matrix whose first and second columns are the minimum and maximum along each dimension, respectively.\n\nReturns (bounds, locs), where bounds is an nactions(a)^n×n+1×a.nz×2 Array{Float64} giving the bounding box for each (run, time step), and locs is an nactions(a)^n Array{Int64} of final locations for each run (or zero if there is no such run).\n\nSee also bounded_runs_iter, which calls this function iteratively to efficiently compute reachable sets for longer time horizons.  Typically one will call deviation on the results of this function to determine deviation from a nominal trajectory.\n\n\n\n\n\n","category":"function"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"After computing a list of reachable sets, safety can be determined by computing its distance from a nominal run.  This is done using the deviation function.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"deviation","category":"page"},{"location":"safety/#ControlTimingSafety.deviation","page":"Checking Safety","title":"ControlTimingSafety.deviation","text":"deviation(a, bounds, reachable; dims=[all], metric=Euclidean(), nominal=[1,1,...])\n\nCompute the deviation from the nominal behavior (default: all 1) that is possible for the given Automaton a, starting from the set of initial states bounds, within the reachable sets.  The deviation is computed using the specified metric from the Distances.jl package.  If dims is specified, the deviation is computed for these dimensions only; otherwise, all dimensions are used.\n\nSee also bounded_runs and bounded_runs_iter, which can be used to compute reachable.\n\n\n\n\n\n","category":"function"},{"location":"safety/#Utility-Functions","page":"Checking Safety","title":"Utility Functions","text":"","category":"section"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"A few utility functions are exported as well.  These support the implementation of the above functions, and are potentially useful to their callers as well.","category":"page"},{"location":"safety/","page":"Checking Safety","title":"Checking Safety","text":"corners_from_bounds\nmerge_bounds","category":"page"},{"location":"safety/#ControlTimingSafety.corners_from_bounds","page":"Checking Safety","title":"ControlTimingSafety.corners_from_bounds","text":"corners_from_bounds(bounds::AbstractMatrix; cycle=false, dims=axes(bounds, 1))\n\nReturns the corners of the n-dimensional interval represented by bounds.  If cycle is true, the first corner is repeated at the end, and the corners are given in Gray code order.  Only the dimensions from dims are considered.\n\n\n\n\n\ncorners_from_bounds(bounds::AbstractVector; cycle=nothing, dims=nothing)\n\nWhen applied to a vector, cast it to a one-column matrix.  cycle and dims are ignored.\n\n\n\n\n\n","category":"function"},{"location":"safety/#ControlTimingSafety.merge_bounds","page":"Checking Safety","title":"ControlTimingSafety.merge_bounds","text":"merge_bounds(b)\n\nMerges an array of bounding boxes b into one.\n\n\n\n\n\n","category":"function"}]
}
